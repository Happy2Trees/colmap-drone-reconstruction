import sys
import os
_original_sys_path = list(sys.path) # Store original sys.path AT THE START
# import argparse # Removed argparse
import numpy as np

# --- Import COLMAP utility scripts ---
# Try to import 'read_write_model.py'
# This is expected to be in a 'scripts' subdirectory or in the same directory as this script.

_read_write_model_module = None
# _plyfile_module = None # Removed

# Attempt 1: From 'src/colmap_utils' subdirectory
_VISUALIZE_PY_DIR = os.path.dirname(os.path.abspath(__file__))
_PROJECT_ROOT = os.path.dirname(os.path.dirname(_VISUALIZE_PY_DIR))
_SCRIPTS_SUBDIR = os.path.join(_PROJECT_ROOT, "src", "colmap_utils")

# Preserve original sys.path for restoration if all imports fail or after script execution.
_current_sys_path_copy = list(sys.path)

if os.path.isdir(_SCRIPTS_SUBDIR):
    sys.path.insert(0, _SCRIPTS_SUBDIR)
    try:
        import read_write_model as rwm_scripts
        _read_write_model_module = rwm_scripts
    except ImportError:
        sys.path = list(_current_sys_path_copy) # Restore if this attempt failed
        pass
    # If successful, _SCRIPTS_SUBDIR remains in path for now.

# Attempt 2: From the same directory as visualize.py (if not already found)
if _read_write_model_module is None:
    sys.path = list(_current_sys_path_copy) # Reset path before trying this, in case attempt 1 modified it
    if _VISUALIZE_PY_DIR not in sys.path:
        sys.path.insert(0, _VISUALIZE_PY_DIR)
    try:
        import read_write_model as rwm_current
        _read_write_model_module = rwm_current
    except ImportError:
        sys.path = list(_current_sys_path_copy) # Restore if this attempt failed
        pass
    # If successful, _VISUALIZE_PY_DIR (if added) remains in path for now.

if _read_write_model_module is None:
    sys.path = _original_sys_path # Critical failure, restore original sys.path fully.
    print("Error: Could not import 'read_write_model.py'.")
    print(f"Please ensure this file (from COLMAP's 'scripts' folder) is either in a subdirectory named 'scripts' "
          f"relative to 'visualize.py' (e.g., at '{_SCRIPTS_SUBDIR}'), or in the same directory as 'visualize.py' (e.g., at '{_VISUALIZE_PY_DIR}').")
    # For debugging, you might want to show the sys.path at the time of failure or the original.
    # print(f"sys.path at failure: {sys.path}") 
    sys.exit(1)
# --- End Import ---


def export_scene_to_obj(output_obj_path, 
                        point_cloud_vertices, point_cloud_colors, point_cube_size,
                        camera_frustum_vertices, camera_frustum_colors, num_cameras):
    """
    Exports 3D points (as small cubes) and camera frustums to an OBJ file.
    Vertices are written with color information.
    Faces are defined for each point-cube and camera pyramid.
    """
    # Create output directory if it doesn't exist
    output_dir = os.path.dirname(output_obj_path)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        
    with open(output_obj_path, 'w') as f:
        num_points = len(point_cloud_vertices) if point_cloud_vertices else 0
        f.write("# OBJ file generated by visualize.py\n")
        f.write(f"# Exporting {num_points} 3D points (as cubes) and {num_cameras} camera frustums.\n\n")

        current_vertex_idx = 1 # OBJ indices are 1-based

        # Write Point Cloud Cubes
        if point_cloud_vertices and point_cube_size > 0:
            f.write("# Point Cloud Cubes\n")
            if len(point_cloud_vertices) != len(point_cloud_colors):
                print("Warning: Point cloud vertex and color lists have different lengths. Colors might be incorrect.")
            
            s = point_cube_size / 2.0 # half side length

            for i in range(len(point_cloud_vertices)):
                center = point_cloud_vertices[i]
                color = point_cloud_colors[i] if i < len(point_cloud_colors) else np.array([128, 128, 128], dtype=np.uint8)
                r_norm, g_norm, b_norm = color[0]/255.0, color[1]/255.0, color[2]/255.0

                # Define 8 vertices for the cube centered at 'center'
                verts = [
                    center + np.array([-s, -s, -s]), center + np.array([s, -s, -s]),
                    center + np.array([s, s, -s]),  center + np.array([-s, s, -s]),
                    center + np.array([-s, -s, s]), center + np.array([s, -s, s]),
                    center + np.array([s, s, s]),   center + np.array([-s, s, s])
                ]
                
                f.write(f"\ng o point_cube_{i+1}\n")
                for v_coord in verts:
                    f.write(f"v {v_coord[0]:.6f} {v_coord[1]:.6f} {v_coord[2]:.6f} {r_norm:.4f} {g_norm:.4f} {b_norm:.4f}\n")
                
                # Define 12 triangle faces for the cube (indices are relative to current_vertex_idx)
                # Front face
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+1} {current_vertex_idx+2}\n")
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+2} {current_vertex_idx+3}\n")
                # Back face
                f.write(f"f {current_vertex_idx+4} {current_vertex_idx+5} {current_vertex_idx+6}\n") # Corrected: was 4,6,5
                f.write(f"f {current_vertex_idx+4} {current_vertex_idx+6} {current_vertex_idx+7}\n") # Corrected: was 4,7,6
                # Top face
                f.write(f"f {current_vertex_idx+3} {current_vertex_idx+2} {current_vertex_idx+6}\n")
                f.write(f"f {current_vertex_idx+3} {current_vertex_idx+6} {current_vertex_idx+7}\n")
                # Bottom face
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+1} {current_vertex_idx+5}\n")
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+5} {current_vertex_idx+4}\n")
                # Right face
                f.write(f"f {current_vertex_idx+1} {current_vertex_idx+5} {current_vertex_idx+6}\n")
                f.write(f"f {current_vertex_idx+1} {current_vertex_idx+6} {current_vertex_idx+2}\n")
                # Left face
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+4} {current_vertex_idx+7}\n")
                f.write(f"f {current_vertex_idx+0} {current_vertex_idx+7} {current_vertex_idx+3}\n")
                
                current_vertex_idx += 8 # 8 vertices per cube
            f.write("\n")
        elif point_cloud_vertices and point_cube_size <= 0:
            f.write("# Point cloud data present, but point_cube_size is zero or negative. Points not written as cubes.\n")
        else:
            f.write("# No point cloud data to write or point_cube_size is zero.\n")

        # Write Camera Frustum Vertices
        camera_frustum_start_idx = current_vertex_idx
        if camera_frustum_vertices:
            f.write("# Camera Frustum Vertices (x y z r g b)\n")
            if len(camera_frustum_vertices) != len(camera_frustum_colors):
                 print("Warning: Camera frustum vertex and color lists have different lengths. Colors might be incorrect.")

            for i in range(len(camera_frustum_vertices)):
                v = camera_frustum_vertices[i]
                c = camera_frustum_colors[i] if i < len(camera_frustum_colors) else np.array([0,255,0], dtype=np.uint8) # Default for cameras green
                r_norm, g_norm, b_norm = c[0]/255.0, c[1]/255.0, c[2]/255.0
                f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f} {r_norm:.4f} {g_norm:.4f} {b_norm:.4f}\n")
                current_vertex_idx += 1
            f.write("\n")
        else:
            f.write("# No camera geometry to write.\n")

        # Write Camera Faces
        if num_cameras > 0 and camera_frustum_vertices:
            f.write("# Camera faces\n")
            for i in range(num_cameras):
                # Each camera has 5 vertices defined in camera_frustum_vertices
                # Their global indices start at camera_frustum_start_idx
                apex_idx = camera_frustum_start_idx + (i * 5) + 0
                b1_idx   = camera_frustum_start_idx + (i * 5) + 1
                b2_idx   = camera_frustum_start_idx + (i * 5) + 2
                b3_idx   = camera_frustum_start_idx + (i * 5) + 3
                b4_idx   = camera_frustum_start_idx + (i * 5) + 4

                f.write(f"\ng camera_frustum_{i+1}\n")
                f.write(f"f {apex_idx} {b1_idx} {b2_idx}\n")
                f.write(f"f {apex_idx} {b2_idx} {b3_idx}\n")
                f.write(f"f {apex_idx} {b3_idx} {b4_idx}\n")
                f.write(f"f {apex_idx} {b4_idx} {b1_idx}\n")
                f.write(f"f {b1_idx} {b3_idx} {b2_idx}\n") # Base: b1,b3,b2
                f.write(f"f {b1_idx} {b4_idx} {b3_idx}\n") # Base: b1,b4,b3 (alternative triangulation)

        elif num_cameras > 0:
             print("Warning: Number of cameras > 0, but no camera frustum vertices provided to write faces.")

    print(f"Successfully wrote {num_points} points (as cubes) and {num_cameras} camera frustums to {output_obj_path}")


def main():
    # --- Parse command line arguments ---
    import argparse
    parser = argparse.ArgumentParser(description="Visualize COLMAP reconstruction as OBJ file")
    parser.add_argument("input_model_dir", help="Path to COLMAP sparse model directory")
    parser.add_argument("--output", default="outputs/visualizations/visualization.obj", 
                        help="Output OBJ file path (default: outputs/visualizations/visualization.obj)")
    parser.add_argument("--min_track_len", type=int, default=3, help="Minimum track length for points (default: 3)")
    parser.add_argument("--max_reproj_error", type=float, default=2.0, help="Maximum reprojection error (default: 2.0)")
    parser.add_argument("--camera_scale", type=float, default=0.2, help="Camera frustum scale (default: 0.2)")
    parser.add_argument("--point_cube_size", type=float, default=0.05, help="Point cube size (default: 0.05)")
    
    args = parser.parse_args()
    
    # --- Configuration --- 
    input_model_dir = args.input_model_dir
    output_obj_path = args.output
    min_track_len = args.min_track_len
    max_reproj_error = args.max_reproj_error
    camera_scale = args.camera_scale
    camera_color_str = "0,255,0" 
    point_default_color_str = "128,128,128"
    point_cube_size = args.point_cube_size
    outlier_distance_percentile_cutoff = 95.0 # e.g., 95.0 to keep points within 95th percentile of distances from centroid. 100.0 to disable.
    # --- End Configuration ---

    # Basic check for placeholder path
    if "path/to/your/colmap/sparse/0" in input_model_dir:
        print(f"Warning: 'input_model_dir' is set to the placeholder value: '{input_model_dir}'")
        print("Please update it in the script to point to your actual COLMAP sparse model directory.")
        # sys.exit(1) 

    print(f"Reading COLMAP model from: {input_model_dir}")
    try:
        cameras, images, points3D_data = _read_write_model_module.read_model(
            path=input_model_dir, ext=".bin"
        )
    except FileNotFoundError:
        print(f"Error: Input model directory not found at '{input_model_dir}'.")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading COLMAP model: {e}")
        sys.exit(1)

    print(f"Found {len(cameras)} cameras, {len(images)} images, and {len(points3D_data)} 3D points initially.")

    # --- Initial 3D Point Filtering (track length and reprojection error) ---
    initial_filtered_points_xyz = []
    initial_filtered_points_colors = []
    num_unfiltered_points = len(points3D_data)

    try:
        default_point_color_rgb = np.array([int(c.strip()) for c in point_default_color_str.split(',')], dtype=np.uint8)
        if len(default_point_color_rgb) != 3: raise ValueError("Invalid color format")
    except ValueError:
        print(f"Error parsing point default color '{point_default_color_str}'. Using [128,128,128].")
        default_point_color_rgb = np.array([128, 128, 128], dtype=np.uint8)

    if points3D_data:
        for point_id, point3D_obj in points3D_data.items():
            if (hasattr(point3D_obj, 'image_ids') and hasattr(point3D_obj, 'error') and 
                hasattr(point3D_obj, 'xyz') and hasattr(point3D_obj, 'rgb')):
                if len(point3D_obj.image_ids) >= min_track_len and point3D_obj.error <= max_reproj_error:
                    initial_filtered_points_xyz.append(point3D_obj.xyz)
                    initial_filtered_points_colors.append(point3D_obj.rgb if (hasattr(point3D_obj, 'rgb') and len(point3D_obj.rgb) == 3) else default_point_color_rgb)
    
    count_after_initial_filter = len(initial_filtered_points_xyz)
    print(f"After initial filtering (track_len>={min_track_len}, reproj_err<={max_reproj_error}): {count_after_initial_filter} points remaining.")

    # --- Outlier Filtering (based on distance from centroid) ---
    output_points_vertices = []
    output_points_colors = []

    if initial_filtered_points_xyz and 0 < outlier_distance_percentile_cutoff < 100.0:
        points_np = np.array(initial_filtered_points_xyz)
        centroid = np.mean(points_np, axis=0)
        print(f"Calculated centroid of initial points: {centroid}")
        distances = np.linalg.norm(points_np - centroid, axis=1)
        distance_threshold = np.percentile(distances, outlier_distance_percentile_cutoff)
        print(f"Outlier distance threshold ({outlier_distance_percentile_cutoff}th percentile): {distance_threshold:.4f}")
        
        for i in range(len(initial_filtered_points_xyz)):
            if np.linalg.norm(initial_filtered_points_xyz[i] - centroid) <= distance_threshold:
                output_points_vertices.append(initial_filtered_points_xyz[i])
                output_points_colors.append(initial_filtered_points_colors[i])
        print(f"After outlier filtering: {len(output_points_vertices)} points remaining (removed {count_after_initial_filter - len(output_points_vertices)} outliers).")
    else:
        output_points_vertices = initial_filtered_points_xyz
        output_points_colors = initial_filtered_points_colors
        if not initial_filtered_points_xyz:
            print("No points after initial filtering to perform outlier removal.")
        else:
            print(f"Outlier percentile filtering skipped (cutoff set to {outlier_distance_percentile_cutoff}%). Using all {count_after_initial_filter} initially filtered points.")

    # --- Camera Processing ---
    all_camera_frustum_vertices = []
    all_camera_frustum_colors = []
    try:
        camera_color_rgb = np.array([int(c.strip()) for c in camera_color_str.split(',')], dtype=np.uint8)
        if len(camera_color_rgb) != 3: raise ValueError("Invalid camera color")
    except ValueError:
        print(f"Error parsing camera color '{camera_color_str}'. Using [0,255,0].")
        camera_color_rgb = np.array([0, 255, 0], dtype=np.uint8)
    
    num_processed_cameras = 0
    if images:
        for image_id, image in images.items():
            num_processed_cameras +=1
            R = _read_write_model_module.qvec2rotmat(image.qvec)
            t = image.tvec
            cam_center_world = -R.T @ t
            s = camera_scale
            z_offset = 1.5 * s 
            base1_cam = np.array([s, -s, z_offset])  
            base2_cam = np.array([-s, -s, z_offset]) 
            base3_cam = np.array([-s, s, z_offset])  
            base4_cam = np.array([s, s, z_offset])   
            apex_cam = np.array([0, 0, 0]) 
            camera_points_cam = [apex_cam, base1_cam, base2_cam, base3_cam, base4_cam]
            for p_cam in camera_points_cam:
                p_world = R.T @ p_cam + cam_center_world
                all_camera_frustum_vertices.append(p_world)
                all_camera_frustum_colors.append(camera_color_rgb)
    print(f"Processed {num_processed_cameras} camera poses.")

    # --- Final Checks and Export ---
    if not output_points_vertices and not all_camera_frustum_vertices:
        print("No 3D points or camera poses to write to OBJ file. Exiting.")
        return

    print(f"Exporting {len(output_points_vertices)} final 3D points and {num_processed_cameras} camera poses to OBJ.")
    export_scene_to_obj(output_obj_path, 
                        output_points_vertices, output_points_colors, point_cube_size,
                        all_camera_frustum_vertices, all_camera_frustum_colors, 
                        num_processed_cameras)

if __name__ == "__main__":
    main()
    # Restore original sys.path if it was changed.
    if 'sys' in globals() and '_original_sys_path' in globals():
        if sys.path != _original_sys_path:
             sys.path = _original_sys_path

